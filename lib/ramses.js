// Generated by CoffeeScript 1.7.1
(function() {
  var buildFragment, detectIndent, fs, glob, path, xcson;

  fs = require('fs');

  glob = require('glob');

  path = require('path');

  detectIndent = require('detect-indent');

  xcson = require('xcson');

  module.exports = buildFragment = function(file) {
    var cwd, indent, raml;
    raml = fs.readFileSync(file, 'utf8').toString();
    indent = detectIndent(raml) || '  ';
    cwd = path.dirname(file) || "./";
    return raml.replace(/(([ \t]*).*)\!include (.+)/g, function(whole, lead, spaces, includes) {
      var afterlead, buffer, found, foundfile, founds, include, infile, isjson, mason, _i, _j, _len, _len1, _ref;
      if (whole.match(/#/)) {
        return whole;
      }
      if (!spaces) {
        spaces = indent;
      }
      buffer = "";
      isjson = false;
      _ref = includes.split(/\s,/);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        include = _ref[_i];
        founds = glob.sync(include, {
          cwd: cwd,
          nonegate: true
        });
        if (!founds.length) {
          throw "Can't resolve \"" + include + "\" in " + file;
        }
        for (_j = 0, _len1 = founds.length; _j < _len1; _j++) {
          found = founds[_j];
          foundfile = path.resolve(cwd, found);
          if (found.match(/\.(c|j)son/)) {
            isjson = true;
            mason = new xcson({
              file: foundfile,
              stringifySpaces: spaces
            });
            infile = mason.toString();
          } else {
            infile = buildFragment(foundfile);
          }
          buffer += infile.replace(/[ \t]*$/, "\n");
        }
      }
      afterlead = " ";
      if (isjson) {
        afterlead = " |\n";
      } else if (buffer.match(/\s*\-/)) {
        afterlead = "\n";
      }
      if (afterlead.match(/\n$/)) {
        buffer = spaces + indent + buffer.replace(/([\n\r])/g, "$1" + spaces + indent);
      }
      return lead.replace(/\s*$/, afterlead) + buffer;
    });
  };

}).call(this);
